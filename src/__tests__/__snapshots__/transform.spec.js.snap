exports[`transform adds default class for exported typed object 1`] = `
"// @flow
import type { BarModelType } from \'./bar\';
import { Bar } from \'./bar\';
import ImmutableModel from \'../../../src/ImmutableModel\';

export type FooModelType = {
  maybeStr: ?string,
  str: string,
  maybeNum: ?number,
  num: number,
  maybeObj: ?Object,
  obj: Object,
  maybeBar: ?BarModelType,
  bar: BarModelType,
  maybeFn: ?Function,
  fn: Function,
};

////////////////////////////////////////////////////////////////////////////////
//
// NOTE: EVERYTHING BELOW THIS COMMENT IS GENERATED. DO NOT MAKE CHANGES HERE.
//
// If you need to update this class, update the corresponding flow type above
// and re-run the flow-immutable-models codemod
//
////////////////////////////////////////////////////////////////////////////////
export class Foo extends ImmutableModel {
  static fromJS(json: FooModelType): Foo {
    const state = Object.assign({}, json);
    state.bar = Bar.fromJS(state.bar);
    return new Foo(Immutable.fromJS(state));
  }

  get maybeStr(): ?string {
    return this._state.get(\'maybeStr\');
  }

  setMaybeStr(maybeStr: ?string): Foo {
    return new Foo(this._state.set(\'maybeStr\', maybeStr));
  }

  get str(): string {
    return this._state.get(\'str\');
  }

  setStr(str: string): Foo {
    return new Foo(this._state.set(\'str\', str));
  }

  get maybeNum(): ?number {
    return this._state.get(\'maybeNum\');
  }

  setMaybeNum(maybeNum: ?number): Foo {
    return new Foo(this._state.set(\'maybeNum\', maybeNum));
  }

  get num(): number {
    return this._state.get(\'num\');
  }

  setNum(num: number): Foo {
    return new Foo(this._state.set(\'num\', num));
  }

  get maybeObj(): ?Object {
    return this._state.get(\'maybeObj\');
  }

  setMaybeObj(maybeObj: ?Object): Foo {
    return new Foo(this._state.set(\'maybeObj\', maybeObj));
  }

  get obj(): Object {
    return this._state.get(\'obj\');
  }

  setObj(obj: Object): Foo {
    return new Foo(this._state.set(\'obj\', obj));
  }

  get maybeBar(): ?Bar {
    return this._state.get(\'maybeBar\');
  }

  setMaybeBar(maybeBar: ?Bar): Foo {
    return new Foo(this._state.set(\'maybeBar\', maybeBar));
  }

  get bar(): Bar {
    return this._state.get(\'bar\');
  }

  setBar(bar: Bar): Foo {
    return new Foo(this._state.set(\'bar\', bar));
  }

  get maybeFn(): ?Function {
    return this._state.get(\'maybeFn\');
  }

  setMaybeFn(maybeFn: ?Function): Foo {
    return new Foo(this._state.set(\'maybeFn\', maybeFn));
  }

  get fn(): Function {
    return this._state.get(\'fn\');
  }

  setFn(fn: Function): Foo {
    return new Foo(this._state.set(\'fn\', fn));
  }
}
"
`;

exports[`transform converts arrays to Immutable lists 1`] = `
"// @flow
import ImmutableModel from \'../../../src/ImmutableModel\';

export type ArrModelType = {
  arr: Array<Object>,
  maybeArr: ?Array<Object>,
};

////////////////////////////////////////////////////////////////////////////////
//
// NOTE: EVERYTHING BELOW THIS COMMENT IS GENERATED. DO NOT MAKE CHANGES HERE.
//
// If you need to update this class, update the corresponding flow type above
// and re-run the flow-immutable-models codemod
//
////////////////////////////////////////////////////////////////////////////////
export class Arr extends ImmutableModel {
  static fromJS(json: ArrModelType): Arr {
    const state = Object.assign({}, json);
    return new Arr(Immutable.fromJS(state));
  }

  get arr(): Immutable.List<Object> {
    return this._state.get(\'arr\');
  }

  setArr(arr: Immutable.List<Object>): Arr {
    return new Arr(this._state.set(\'arr\', arr));
  }

  get maybeArr(): ?Array<Object> {
    return this._state.get(\'maybeArr\');
  }

  setMaybeArr(maybeArr: ?Array<Object>): Arr {
    return new Arr(this._state.set(\'maybeArr\', maybeArr));
  }
}
"
`;

exports[`transform converts referenced types in getters and setters 1`] = `
"// @flow
import type { BarModelType } from \'./bar\';
import { Bar } from \'./bar\';
import ImmutableModel from \'../../../src/ImmutableModel\';

export type FooModelType = {
  ref: BarModelType,
  maybeRef: ?BarModelType,
  str: string,
};

////////////////////////////////////////////////////////////////////////////////
//
// NOTE: EVERYTHING BELOW THIS COMMENT IS GENERATED. DO NOT MAKE CHANGES HERE.
//
// If you need to update this class, update the corresponding flow type above
// and re-run the flow-immutable-models codemod
//
////////////////////////////////////////////////////////////////////////////////
export class Foo extends ImmutableModel {
  static fromJS(json: FooModelType): Foo {
    const state = Object.assign({}, json);
    state.ref = Bar.fromJS(state.ref);
    return new Foo(Immutable.fromJS(state));
  }

  get ref(): Bar {
    return this._state.get(\'ref\');
  }

  setRef(ref: Bar): Foo {
    return new Foo(this._state.set(\'ref\', ref));
  }

  get maybeRef(): ?Bar {
    return this._state.get(\'maybeRef\');
  }

  setMaybeRef(maybeRef: ?Bar): Foo {
    return new Foo(this._state.set(\'maybeRef\', maybeRef));
  }

  get str(): string {
    return this._state.get(\'str\');
  }

  setStr(str: string): Foo {
    return new Foo(this._state.set(\'str\', str));
  }
}
"
`;

exports[`transform does not instantiate imported types 1`] = `
"// @flow
import ImmutableModel from \'../../../src/ImmutableModel\';
import type { Comparator } from \'./Comparator\';

export type NonClassImportedModelType = {
  comparator: Comparator,
};

////////////////////////////////////////////////////////////////////////////////
//
// NOTE: EVERYTHING BELOW THIS COMMENT IS GENERATED. DO NOT MAKE CHANGES HERE.
//
// If you need to update this class, update the corresponding flow type above
// and re-run the flow-immutable-models codemod
//
////////////////////////////////////////////////////////////////////////////////
export class NonClassImported extends ImmutableModel {
  static fromJS(json: NonClassImportedModelType): NonClassImported {
    const state = Object.assign({}, json);
    return new NonClassImported(Immutable.fromJS(state));
  }

  get comparator(): Comparator {
    return this._state.get(\'comparator\');
  }

  setComparator(comparator: Comparator): NonClassImported {
    return new NonClassImported(this._state.set(\'comparator\', comparator));
  }
}
"
`;

exports[`transform does not instantiate inline non-class props 1`] = `
"// @flow
import ImmutableModel from \'../../../src/ImmutableModel\';

type Operator = \"*\" | \"/\" | \"+\" | \"-\";
export type Comparator = \"<\" | \">\" | \"=\" | \"!=\";

export type NonClassModelType = {
  operator: Operator,
  comparator: Comparator,
};

////////////////////////////////////////////////////////////////////////////////
//
// NOTE: EVERYTHING BELOW THIS COMMENT IS GENERATED. DO NOT MAKE CHANGES HERE.
//
// If you need to update this class, update the corresponding flow type above
// and re-run the flow-immutable-models codemod
//
////////////////////////////////////////////////////////////////////////////////
export class NonClass extends ImmutableModel {
  static fromJS(json: NonClassModelType): NonClass {
    const state = Object.assign({}, json);
    return new NonClass(Immutable.fromJS(state));
  }

  get operator(): Operator {
    return this._state.get(\'operator\');
  }

  setOperator(operator: Operator): NonClass {
    return new NonClass(this._state.set(\'operator\', operator));
  }

  get comparator(): Comparator {
    return this._state.get(\'comparator\');
  }

  setComparator(comparator: Comparator): NonClass {
    return new NonClass(this._state.set(\'comparator\', comparator));
  }
}
"
`;

exports[`transform handles Immutable lists and maps 1`] = `
"// @flow
import * as Immutable from \'immutable\';
import type { BarModelType } from \'./bar\';
import { Bar } from \'./bar\';
import ImmutableModel from \'../../../src/ImmutableModel\';

export type FooModelType = {
  list: Immutable.List<any>,
  maybeList: ?Immutable.List<BarModelType>,
  map: Immutable.Map<any, any>,
  maybeMap: ?Immutable.Map<string, BarModelType>,
};

////////////////////////////////////////////////////////////////////////////////
//
// NOTE: EVERYTHING BELOW THIS COMMENT IS GENERATED. DO NOT MAKE CHANGES HERE.
//
// If you need to update this class, update the corresponding flow type above
// and re-run the flow-immutable-models codemod
//
////////////////////////////////////////////////////////////////////////////////
export class Foo extends ImmutableModel {
  static fromJS(json: FooModelType): Foo {
    const state = Object.assign({}, json);
    return new Foo(Immutable.fromJS(state));
  }

  get list(): Immutable.List<any> {
    return this._state.get(\'list\');
  }

  setList(list: Immutable.List<any>): Foo {
    return new Foo(this._state.set(\'list\', list));
  }

  get maybeList(): ?Immutable.List<Bar> {
    return this._state.get(\'maybeList\');
  }

  setMaybeList(maybeList: ?Immutable.List<Bar>): Foo {
    return new Foo(this._state.set(\'maybeList\', maybeList));
  }

  get map(): Immutable.Map<any, any> {
    return this._state.get(\'map\');
  }

  setMap(map: Immutable.Map<any, any>): Foo {
    return new Foo(this._state.set(\'map\', map));
  }

  get maybeMap(): ?Immutable.Map<string, Bar> {
    return this._state.get(\'maybeMap\');
  }

  setMaybeMap(maybeMap: ?Immutable.Map<string, Bar>): Foo {
    return new Foo(this._state.set(\'maybeMap\', maybeMap));
  }
}
"
`;

exports[`transform initializes arrays of other model types 1`] = `
"// @flow
import ImmutableModel from \'../../../src/ImmutableModel\';
import { Bar } from \'./bar\';
import type { BarModelType } from \'./bar\';

export type ArrModelType = {
  arr: Array<BarModelType>,
};

////////////////////////////////////////////////////////////////////////////////
//
// NOTE: EVERYTHING BELOW THIS COMMENT IS GENERATED. DO NOT MAKE CHANGES HERE.
//
// If you need to update this class, update the corresponding flow type above
// and re-run the flow-immutable-models codemod
//
////////////////////////////////////////////////////////////////////////////////
export class Arr extends ImmutableModel {
  static fromJS(json: ArrModelType): Arr {
    const state = Object.assign({}, json);
    state.arr = state.arr.map(item => Bar.fromJS(item));
    return new Arr(Immutable.fromJS(state));
  }

  get arr(): Immutable.List<Bar> {
    return this._state.get(\'arr\');
  }

  setArr(arr: Immutable.List<Bar>): Arr {
    return new Arr(this._state.set(\'arr\', arr));
  }
}
"
`;
